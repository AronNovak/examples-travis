<?php
// $Id$

/**
 * @file
 * This is an example outlining how a module can be used to define a filter
 * to be run on user-submitted content before it is output to the browser.
 *
 * To show all the capabilities of the filter system, we will define two filters
 * in this module. One will substitute the string "foo" with an administratively-
 * defined replacement string. The other will find a custom XML tag, <time />, and
 * replace it by the current time.
 */

/**
 * Implements hook_filter_info().
 *
 * Here we define the diferent filters provided by the module. For the example,
 * time_filter is a very static and simple replacement, but it requires some
 * preparation of the string because of the special html tags < and >. The
 * foo_filter is more complex, including its own settings and inline tips.
 */
function filter_example_filter_info() {
  $filters['foo_filter'] = array(
    'title' => t('Foo filter'),
    'description' => t('Every instance of "foo" in the input text will be replaced with a preconfigured replacement.'),
    'process callback'  => '_filter_example_filter_foo_process',
    'default settings' => array(
      'foo_default_replacement' => 'bar',
    ),
    'settings callback' => '_filter_example_filter_foo_settings',
    'tips callback' => '_filter_example_filter_foo_tips',
  );
  $filters['time_filter'] = array(
    'title' => t('Time tag'),
    'description' => t('Every instance of the special &lt;time /&gt; tag will be replaced with the current date and time in the user\'s specified time zone.'),
    'prepare callback' => '_filter_example_filter_time_prepare',
    'process callback' => '_filter_example_filter_time_process',
  );
  return $filters;
}

/*
 * Foo filter
 *
 * Drupal has several content formats (they are not filters), and in our example
 * the foo replacement can be configured for each one of them, allowing an html
 * or php replacement, so the module includes a settings callback, with options
 * to configure that replacements. Also, a Tips callback will help showing the
 * current replacement for the content type being edited.
 */

/*
 * Settings callback for foo filter
 *
 * Make use of $format to have different replacements for every input format
 * Since we allow the administrator to define the string that gets
 * substituted when "foo" is encountered, we need to provide an
 * interface for this customization. The object format is also an argument of
 * the callback
 *
 * Settings of this form is stored in database by the filter module, and the
 * can be read from $filter argument
 */
function _filter_example_filter_foo_settings($form, $form_state, $filter, $format, $defaults) {
  $filter_form["filter_example_foo_" . $format->format] = array(
            '#type' => 'textfield',
            '#title' => t('Substitution string'),
    '#default_value' => (isset($filter->settings["filter_example_foo_" . $format->format])) ? $filter->settings["filter_example_foo_" . $format->format] : $defaults['foo_default_replacement'],
            '#description' => t('The string to substitute for "foo" everywhere in the text.')
  );
  return $filter_form;
}

/*
 * Foo filter process callback
 *
 * The actual filtering is performed here. The supplied text should be
 * returned, once any necessary substitutions have taken place.
 */
function _filter_example_filter_foo_process($text, $filter, $format) {
  $replacement = (isset($filter->settings["filter_example_foo_" . $format->format])) ? $filter->settings["filter_example_foo_" . $format->format] : 'bar';
  return str_replace('foo', $replacement, $text);
}


/**
 * Filter tips callback for HTML filter.
 *
 * the tips callback allows filters to provide help text to users during the content
 * editing process. Short tips are provided on the content editing screen, while
 * long tips are provided on a separate linked page. Short tips are optional,
 * but long tips are highly recommended.
 */
function _filter_example_filter_foo_tips($filter, $format, $long = FALSE) {
  $replacement = (isset($filter->settings["filter_example_foo_" . $format->format])) ? $filter->settings["filter_example_foo_" . $format->format] : 'bar';
  if (!$long) {
    // This string will be shown in the content add/edit form
    return '<p>' . t('<em>foo</em> replaced with %replacement.', array('%replacement' => $replacement)) . '</p>';
  }
  else {
    return t('Every instance of "foo" in the input text will be replaced with "%replacement".', array('%replacement' => $replacement));
  }
}

/*
 * time filter.
 *
 * This filter is a little trickier to implement than the previous one.
 * Since the input involves special HTML characters (< and >) we have to
 * run the filter before HTML is escaped/stripped by other filters. But
 * we want to use HTML in our result as well, and so if we run this filter
 * first our replacement string could be escaped or stripped. The solution
 * is to use the "prepare" operation to escape the special characters, and
 * to later replace our escaped version in the "process" step.
 */

/*
 * time filter prepare callback
 *
 * We'll use the bytes  \xEF\xA3\xBF and \xEF\xA3\xBE to replace < and > here.
 * These bytes are not valid in UTF-8 data and thus unlikely to cause problems.
 */
function _filter_example_filter_time_prepare($text, $filter) {
  return preg_replace('!<time ?/>!', "\xEF\xA3\xBFtime /\xEF\xA3\xBE", $text);
}

/*
 * time filter process callback
 *
 * Now, in the "process" step, we'll search for our escaped time tags and
 * to the real filtering.
 */
function _filter_example_filter_time_process($text, $filter) {
  return str_replace("\xEF\xA3\xBFtime /\xEF\xA3\xBE", '<em>' . format_date(time()) . '</em>', $text);
}
